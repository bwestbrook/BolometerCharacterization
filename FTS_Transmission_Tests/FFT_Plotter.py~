from copy import copy, deepcopy
from scipy.fftpack import fft, fftfreq, fftshift
from scipy.signal import blackman, hanning
from scipy import interpolate
from settings import settings
from numerical_processing import Fourier, BeamSplitter
import pylab as pl
import numpy as np
import sys
import os


def load_simulation_data(data_path):
    '''
    Inputs:
        data_path:  the path to the .fft data file (string)
    Outputs:
        frequency_vector: the extracted frequency vector
        transmission_vector: the extracted frequency vector
    Returns a frequency and transmission vector from the data file
    produced by Toki's LabView software
    '''
    with open(data_path, 'r') as file_handle:
        lines = file_handle.readlines()
        frequency_vector = np.zeros(len(lines))
        transmission_vector = np.zeros(len(lines))
        for i, line in enumerate(lines):
            frequency = line.split('\t')[0]
            transmission = line.split('\t')[1].strip('\n')
            transmission = 10.0 ** (float(transmission)/10.0)
            np.put(frequency_vector, i, float(frequency))
            np.put(transmission_vector, i, float(transmission))
    normalized_transmission_vector = transmission_vector / max(transmission_vector)
    return frequency_vector, transmission_vector, normalized_transmission_vector


def load_optical_element_data(data_path, optical_element='mmf'):
    '''
    Inputs:
        data_path:  the path to the .fft data file (string)
    Outputs:
        frequency_vector: the extracted frequency vector
        transmission_vector: the extracted frequency vector
    Returns a frequency and transmission vector from the data file
    produced by Toki's LabView software
    '''
    with open(data_path, 'r') as file_handle:
        lines = file_handle.readlines()
        frequency_vector = np.zeros(len(lines))
        transmission_vector = np.zeros(len(lines))
        for i, line in enumerate(lines):
            frequency = line.split('\t')[0]
            transmission = line.split('\t')[1].strip('\n')
            np.put(frequency_vector, i, float(frequency))
            np.put(transmission_vector, i, float(transmission))
    if optical_element == 'mmf':
        mmf_data_selector = np.logical_and(frequency_vector < 450, frequency_vector > 150)
        mmf_zero_selector = np.logical_and(frequency_vector < 450, frequency_vector > 400)
        normalized_transmission_vector = (transmission_vector - np.median(transmission_vector[mmf_zero_selector]))
        normalized_transmission_vector = normalized_transmission_vector / max(normalized_transmission_vector[mmf_data_selector])
    elif optical_element == 'beam_splitter':
        normalized_transmission_vector = transmission_vector / max(transmission_vector)
    return frequency_vector, transmission_vector, normalized_transmission_vector


def load_FFT_data(data_path, frequency_):
    '''
    Inputs:
        data_path:  the path to the .fft data file (string)
    Outputs:
        frequency_vector: the extracted frequency vector
        transmission_vector: the extracted frequency vector
    Returns a frequency and transmission vector from the data file
    produced by Toki's LabView software
    '''
    for file_name in os.listdir(data_path):
        print file_name
        if file_name[-3:] == 'fft':
            data_path = os.path.join(data_path, file_name)
    with open(data_path, 'r') as file_handle:
            lines = file_handle.readlines()
            frequency_vector = np.zeros(len(lines))
            transmission_vector = np.zeros(len(lines))
            for i, line in enumerate(lines):
                    frequency = line.split('\t')[0]
                    transmission = line.split('\t')[1]
                    np.put(frequency_vector, i, frequency)
                    np.put(transmission_vector, i, transmission)
    if frequency_ == '4ad0':
        #import ipdb;ipdb.set_trace()
        frequency_vector = np.extract(frequency_vector < 100, frequency_vector)
        transmission_vector = np.extract(frequency_vector < 100, transmission_vector)
    normalized_transmission_vector = transmission_vector / max(transmission_vector)
    return frequency_vector, transmission_vector, normalized_transmission_vector


def load_IF_data(data_path, distance_per_step=250.39e-9):
    '''
    Inputs:
        data_path:  the path to the .if data file (string)
        distance_per_step: for converstion to physical units
           - Default value is 250.39e-9 m (Bill's FTS)
    Outputs:
        x_position_vector: the extracted x position vector in mm
        transmission_vector: the extracted frequency vector
    Returns a frequency and transmission vector from the inteferogram data and the input
    params of the FTS setup being used
    '''
    for file_name in os.listdir(data_path):
        if file_name[-2:] == 'if':
            data_path = os.path.join(data_path, file_name)
    with open(data_path, 'r') as file_handle:
            lines = file_handle.readlines()
            position_vector = np.zeros(len(lines))
            transmission_vector = np.zeros(len(lines))
            for i, line in enumerate(lines):
                stepper_position = float(line.split('\t')[0]) * distance_per_step * 1e3
                transmission = float(line.split('\t')[1])
                np.put(position_vector, i, stepper_position)
                np.put(transmission_vector, i, transmission)
    return position_vector, transmission_vector


def divide_out_optical_element_response(frequency_vector, optical_element_frequency_vector, optical_element_transmission_vector, normalized_transmission_vector,
                                        optical_element='mmf', band_center=350):
    '''
    This divides out the mmf filter response between 40 and 450 GHz (data our side of this is too noisy)
    Inputs:
        frequency_vector: the frequency vector on to which the mmf data that will interpolated
        mmf_frequency_vector: the native frequency vector of the mmf data that will interpolated
        normalized_transmission_vector: FFT data to divide the response out of
        normalized_mmf_transmission_vector: FFT data from the mmf which will be divided into the other vector
        band_edges: approximated band_edges where you want to divide out the frequency response (default is for 350 band most affected by the mmf)
    Outputs:
        corrected_transmission_vector: the divided spectra with the response removed
    '''
    band_edges_dict = {40: (30, 50), 60: (45, 75), 90: (75, 110), 150: (120, 180), 220: (180, 220), 280: (240, 300), 350: (300, 380)}
    band_edges = band_edges_dict[int(band_center)]
    corrected_transmission_vector = copy(normalized_transmission_vector)
    if optical_element == 'mmf':
        band_lower = band_edges[0]
        band_upper = band_edges[1]
        mmf_data_selector = np.logical_and(optical_element_frequency_vector < band_upper, optical_element_frequency_vector > band_lower)
        data_selector = np.logical_and(frequency_vector < band_upper, frequency_vector > band_lower)
        transmission_vector_to_divide = np.interp(frequency_vector[data_selector], optical_element_frequency_vector[mmf_data_selector],
                                                  optical_element_transmission_vector[mmf_data_selector])
        corrected_transmission_vector[data_selector] = normalized_transmission_vector[data_selector] / transmission_vector_to_divide
    elif optical_element == 'beam_splitter':
        transmission_vector_to_divide = np.interp(frequency_vector, optical_element_frequency_vector, optical_element_transmission_vector)
        corrected_transmission_vector = normalized_transmission_vector / transmission_vector_to_divide
    corrected_transmission_vector = corrected_transmission_vector / np.max(corrected_transmission_vector)
    quick_plot = True
    if quick_plot:
        if optical_element == 'beam_splitter':
            data_selector = np.asarray(np.ones(frequency_vector.size), dtype=bool)
            mmf_data_selector = np.asarray(np.ones(optical_element_frequency_vector.size), dtype=bool)
        pl.plot(frequency_vector[data_selector], normalized_transmission_vector[data_selector], 'r', lw=3, hold=True, label='Input')
        pl.plot(frequency_vector[data_selector], corrected_transmission_vector[data_selector], 'b', hold=True, label='Corrected')
        pl.plot(optical_element_frequency_vector[mmf_data_selector], optical_element_transmission_vector[mmf_data_selector], 'g', label='Divisor')
        pl.xlim(band_edges[0], band_edges[1])
        pl.xlabel('Frequency (GHz)', fontsize=16)
        pl.ylabel('Response', fontsize=16)
        pl.title('Division Inspection for {0}'.format(optical_element), fontsize=16)
        pl.ylim(-1, 2)
        pl.legend(loc='best')
        pl.show()
    #import ipdb;ipdb.set_trace()
    return corrected_transmission_vector


def plot_IF_data(position_vector, transmission_vector, color='b', lw=1, fig=None):
    '''
    Overview:
        This function will take the output of Load_FFT_Data
    Inputs:
        position_vector: the x_position vector (in mm)
        transmission_vector: equal in length to position vector showing FTS transmission
    Outputs:
        fig: a pyplot fig object of the IF data
    '''
    if fig is None:
            fig = pl.figure(figsize=(10, 5))
    ax2 = fig.add_subplot(212)
    ax2.plot(position_vector, transmission_vector, color, label='IF Data', lw=lw)
    fig.subplots_adjust(bottom=0.15, top =0.96, left=0.13, right=0.68, hspace=0.44)
    ax2.tick_params(labelsize=20)
    ax2.set_xlabel('X position (mm)', fontsize=16)
    ax2.set_ylabel('Transmission', fontsize=16)
    ax2.tick_params(labelsize=12)
    return fig


def plot_FFT_data(frequency_vector, transmission_vector, color='b', label='', lw=1, data_only=True, fig=None,
                  pixel='HF_Triplexer'):
    '''
    This function will take the output of Load_FFT_Data
    '''
    if fig is None:
            fig = pl.figure(figsize=(10, 5))
    if data_only:
        ax1 = fig.add_subplot(211)
        ax1.set_xlabel('Frequency (GHz)', fontsize=16)
        ax1.set_ylabel('Normalized \n Transmission', fontsize=16)
        ax1.tick_params(labelsize=12)
    else:
        ax1 = fig.add_subplot(111)
        ax1.set_xlabel('Frequency (GHz)', fontsize=24)
        ax1.set_ylabel('Normalized Transmission', fontsize=24)
        ax1.tick_params(labelsize=20)
    ax1.plot(frequency_vector, transmission_vector, color, label=label, lw=lw)
    fig.subplots_adjust(bottom=0.17, top =0.96, left=0.10, right=0.68)
    if pixel == 'LF_Triplexer':
        pl.xlim([0, 300])
    else:
        pl.xlim([0, 600])
    pl.ylim([-0.050, 1.05])
    return fig


def return_data_query_dicts(frequencies=['220'], pixels=['Tetraplexer'], dates=['2015_06_16'], wafers=['BW1_8'], dies=['3_5']):
    '''
    Inputs:
        frequencies (list) - a list of frequencies you wish to plot
        pixels (list) - a list of pixel types.  A common index between list will be plotted together
        dates (list) - a list of dates on which data was taken
        dies (list) - a list of dies you wish to plot
        wafers (list) - a list of wafers you wish to plot
    Outputs:
        list_of_dicts and list of dictionaries contiaining all of the paths and labels needed to plot the data
        in a nice way
    '''
    colors = ['g', 'b', 'r', 'k', 'm']
    list_of_dicts = []
    for j, frequency in enumerate(frequencies):
        dict_ = {}
        pixel = pixels[j]
        date = dates[j]
        wafer = wafers[j]
        die = dies[j]
        dict_.update({'frequency': frequency})
        dict_.update({'pixel': pixel})
        dict_.update({'simulations': {'data_path': "Simulations/{0}_{1}_Transmission.dat".format(frequency, pixel),
                                      'label': '{0} {1} (Sim)'.format(frequency, pixel)}})
        dict_.update({'measurements': {'data_path': "Data/{0}/{1}/Wafer_{2}_Die_{3}/{4}/ToLoad".format(pixel, date, wafer, die, frequency),
                                       'data_path_if': "./Data/{0}/{1}/Wafer_{2}_Die_{3}/{4}/ToLoad".format(pixel, date, wafer, die, frequency),
                                       'mmf_fft_path': "./Output/MMF_Transmission/12icm_Filter_Transmission.fft",
                                       'bs_fft_path': "./Output/Beam_Splitter_Efficiency/5_mil_beamsplitter_efficiency.dat",
                                       'label': '{0} {1}'.format(frequency, pixel), 'color': '#BD0470'}})
        if str(frequency) == '40':
            if pixel == 'LF_Triplexer':
                dict_['simulations'].update({'color': 'b'})
                dict_['measurements'].update({'color': '#0A2E30'})
        if str(frequency) == '60':
            if pixel == 'LF_Triplexer':
                dict_['simulations'].update({'color': 'm'})
                dict_['measurements'].update({'color': '#8A7616'})
        if str(frequency) == '90':
            if pixel == 'Tetraplexer':
                dict_['simulations'].update({'color': 'k'})
                dict_['measurements'].update({'color': '#AD1818'})
            elif pixel == 'LF_Triplexer':
                dict_['simulations'].update({'color': 'k'})
                dict_['measurements'].update({'color': '#AD1818'})
        if str(frequency) == '150':
            if pixel == 'Tetraplexer':
                dict_['simulations'].update({'color': '#4605ED'})
                dict_['measurements'].update({'color': '#F07205'})
        if str(frequency) == '220':
            if pixel == 'HF_Triplexer':
                dict_['simulations'].update({'color': 'g'})
                dict_['measurements'].update({'color': 'm'})
            elif pixel == 'Tetraplexer':
                dict_['simulations'].update({'color': 'm'})
                dict_['measurements'].update({'color': 'g'})
        if str(frequency) == '280':
            if pixel == 'HF_Triplexer':
                dict_['simulations'].update({'color': 'r'})
                dict_['measurements'].update({'color': 'c'})
            elif pixel == 'Tetraplexer':
                dict_['simulations'].update({'color': 'c'})
                dict_['measurements'].update({'color': 'r'})
        if str(frequency) == '350':
            if pixel == 'HF_Triplexer':
                dict_['simulations'].update({'color': 'k'})
                dict_['measurements'].update({'color': 'y'})
            elif pixel == 'DsDp':
                dict_['simulations'].update({'color': 'y'})
                dict_['measurements'].update({'color': 'k'})
        print frequency, pixel, date
        list_of_dicts.append(deepcopy(dict_))
    return list_of_dicts


def process_all_input_dicts(list_of_dicts, divide_beam_splitter_response=True, divide_mmf_response=True, data=True, co_plot=False,
                            simulations=False, both=False, savefig=True):
    '''
    This loops through the list of dictionaries returned by return_data_query_dicts
    and plots them according to the kwargs
        - data (Boolean) will plot the FFT data
        - simulation (Boolean) will plot the simulated data
        - both (Boolean) will plot the FFT and simulation data
        - co_plot (Boolean) will overplot mulitple frequencies FFT and simulation data
    '''
    fourier = Fourier()
    print data, co_plot, simulations, both
    fig = None
    frequencies = []
    pixels = []
    data_only = False
    for dict_ in list_of_dicts:
        frequency = dict_['frequency']
        label = dict_['measurements']['label']
        color = dict_['measurements']['color']
        sim_color = dict_['simulations']['color']
        sim_label = dict_['simulations']['label']
        pixel = dict_['pixel']
        data_path = dict_['measurements']['data_path']
        data_path_if = dict_['measurements']['data_path_if']
        sim_data_path = dict_['simulations']['data_path']
        mmf_fft_data_path = dict_['measurements']['mmf_fft_path']
        bs_fft_data_path = dict_['measurements']['bs_fft_path']
        if_position_vector, if_transmission_vector = load_IF_data(data_path_if)
        mmf_frequency_vector, mmf_transmission_vector, normalized_mmf_transmission_vector = load_optical_element_data(mmf_fft_data_path, optical_element='mmf')
        bs_frequency_vector, bs_transmission_vector, normalized_bs_transmission_vector = load_optical_element_data(bs_fft_data_path, optical_element='beam_splitter')
        fft_frequency_vector, fft_transmission_vector = fourier.convert_IF_to_FFT_data(if_position_vector, if_transmission_vector, quick_plot=False)
        if not pixel == 'LF_Triplexer':
            sim_frequency_vector, sim_transmission_vector, sim_normalized_transmission_vector = load_simulation_data(sim_data_path)
        frequency_vector, transmission_vector, normalized_transmission_vector = load_FFT_data(data_path, frequency)
        if settings.divide_mmf_response:
            normalized_transmission_vector= divide_out_optical_element_response(frequency_vector, mmf_frequency_vector, mmf_transmission_vector,
                                                                                normalized_transmission_vector, optical_element='mmf', band_center=frequency)
        if settings.divide_beam_splitter_response:
            normalized_transmission_vector= divide_out_optical_element_response(frequency_vector, bs_frequency_vector, bs_transmission_vector,
                                                                                normalized_transmission_vector, optical_element='beam_splitter', band_center=frequency)
        if simulations:
            fig = plot_FFT_data(sim_frequency_vector, sim_normalized_transmission_vector, color=color, data_only=data_only, lw=2,
                                label=label, fig=fig, pixel=pixel)
        elif both and not co_plot:
            data_frequency_vector, data_transmission_vector, data_normalized_transmission_vector =\
                frequency_vector, transmission_vector, normalized_transmission_vector
            fig = plot_FFT_data(data_frequency_vector, data_normalized_transmission_vector, data_only=data_only,
                                color=color, label=label, fig=None, pixel=pixel)
            fig = plot_FFT_data(sim_frequency_vector, sim_normalized_transmission_vector, data_only=data_only,
                                color=sim_color, label=sim_label, fig=fig, lw=2, pixel=pixel)
        elif co_plot:
            fig = plot_FFT_data(frequency_vector, normalized_transmission_vector, color=color, label=label, fig=fig, data_only=data_only, pixel=pixel)
            if both:
                fig = plot_FFT_data(sim_frequency_vector, sim_normalized_transmission_vector, data_only=data_only,
                                    color=sim_color, label=sim_label, fig=fig, lw=2, pixel=pixel)
        elif data:
            if not co_plot and not both and not simulations:
                data_only = True
            #fig = plot_FFT_data(fft_frequency_vector, fft_transmission_vector, color='g', label='python fft')
            fig = plot_FFT_data(frequency_vector, normalized_transmission_vector, color=color, data_only=data_only, label=label, fig=fig, pixel=pixel)
            fig = plot_IF_data(if_position_vector, if_transmission_vector, color=color, fig=fig)
        frequencies.append(str(frequency))
        pixels.append(str(pixel))
    for axis in fig.get_axes():
        handles, labels = axis.get_legend_handles_labels()
        axis.legend(handles, labels, numpoints=1, loc=2, bbox_to_anchor=(1.01, 1.0))
    if savefig:
        frequencies_str = '_'.join(frequencies)
        pixels_str = '_'.join(pixels)
        if data_only:
            save_str = './Output/FFT_Data_Only_{0}_GHz_{1}.png'.format(frequencies_str, pixels_str)
        elif co_plot:
            save_str = './Output/FFT_Co_Plot_{0}_GHz_{1}.png'.format(frequencies_str, pixels_str)
        else:
            save_str = './Output/FFT_{0}_GHz_{1}.png'.format(frequencies_str, pixels_str)
        print 'Saving figure to {0}'.format(save_str)
        fig.savefig(save_str)
    fig.show()
    _ask_user_if_they_want_to_quit()


def run():
    list_of_dicts = return_data_query_dicts(settings.frequencies, settings.pixels, settings.dates, settings.wafers, settings.dies)
    process_all_input_dicts(list_of_dicts, data=settings.data, co_plot=settings.co_plot, simulations=settings.simulations, both=settings.both,
                            divide_mmf_response=settings.divide_mmf_response, divide_beam_splitter_response=settings.divide_beam_splitter_response)

def _ask_user_if_they_want_to_quit():
    quit_boolean = raw_input('Press q to q(uit), any other key to continue:\n')
    if quit_boolean == 'q':
        exit()


if __name__ == '__main__':
	run()
        #run_test()
